---
name: AI Combat Tactics for Companions
status: completed
created: 2026-02-05T19:06:45Z
updated: 2026-02-05T19:21:30Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/53
depends_on: [43, 55]
parallel: false
conflicts_with: []
---

# AI Combat Tactics for Companions

## Description

Implement a TacticsEngine that governs companion combat decision-making. The engine uses companion archetypes, personality traits, and battlefield state to make intelligent tactical choices including positioning, target selection, and ability usage. This creates immersive, believable companion behavior without requiring constant player micromanagement.

## Acceptance Criteria

- [ ] Implement `TacticsEngine` class for companion combat decisions
- [ ] Define archetype-based tactical behaviors (tank positions front, healer stays back, etc.)
- [ ] Implement intelligent target selection logic based on threat assessment
- [ ] Create ability/spell usage decision system
- [ ] Support positional awareness and movement decisions
- [ ] Integrate with existing combat system (initiative, action economy)
- [ ] Add personality influence on tactical choices
- [ ] Write comprehensive unit tests with combat scenarios
- [ ] Document tactical decision algorithms

## Technical Details

### TacticsEngine Class

```python
from dataclasses import dataclass
from typing import Optional
from enum import Enum

class TacticalPriority(Enum):
    SURVIVE = "survive"
    PROTECT_ALLY = "protect_ally"
    ELIMINATE_THREAT = "eliminate_threat"
    SUPPORT_PARTY = "support_party"
    CONTROL_BATTLEFIELD = "control_battlefield"

@dataclass
class TacticalDecision:
    action_type: str              # "attack", "move", "ability", "item", "dodge"
    target: Optional[str]         # Target ID (enemy, ally, or location)
    ability: Optional[str]        # Specific ability/spell if applicable
    priority: TacticalPriority
    confidence: float             # 0-1: How confident the AI is in this choice
    reasoning: str                # Explanation for debugging/transparency

class TacticsEngine:
    """Makes combat decisions for companion NPCs."""

    def __init__(self, companion: CompanionProfile, combat_state: CombatState):
        self.companion = companion
        self.combat_state = combat_state

    def decide_action(self) -> TacticalDecision:
        """Determine the best action for this companion's turn."""
        pass

    def evaluate_targets(self) -> list[tuple[str, float]]:
        """Score all potential targets by tactical value."""
        pass

    def select_ability(self, target: str) -> Optional[str]:
        """Choose the best ability to use against a target."""
        pass

    def calculate_positioning(self) -> Optional[tuple[int, int]]:
        """Determine optimal position on battlefield."""
        pass
```

### Archetype-Based Tactics

#### Tank Tactics
- Position: Front line, between enemies and allies
- Priority: Draw attacks, protect squishier allies
- Target Selection: Nearest threat to allies, not necessarily highest damage
- Abilities: Use taunt, shield abilities proactively

#### Healer Tactics
- Position: Back line, near wounded allies
- Priority: Keep party alive, prioritize lowest HP%
- Target Selection: Allies below 50% HP, then buffs, then damage
- Abilities: Heal when ally < 50%, cure conditions immediately

#### Striker Tactics
- Position: Flanking or behind enemies
- Priority: Eliminate high-value targets quickly
- Target Selection: Lowest HP enemies, spellcasters, archers
- Abilities: High damage abilities, save resources for key targets

#### Support Tactics
- Position: Mid-line with sightlines to all allies
- Priority: Maximize party effectiveness through buffs/debuffs
- Target Selection: Buff strongest attackers, debuff dangerous enemies
- Abilities: Buffs at combat start, debuffs on tough enemies

### Target Selection Algorithm

```python
def calculate_target_score(self, target: Combatant) -> float:
    score = 0.0

    # Base threat assessment
    score += target.damage_potential * 0.3
    score += (1 - target.hp_percentage) * 0.2  # Lower HP = easier kill

    # Archetype modifiers
    if self.companion.archetype == CompanionArchetype.TANK:
        # Prioritize targets threatening allies
        score += target.threat_to_allies * 0.4
    elif self.companion.archetype == CompanionArchetype.STRIKER:
        # Prioritize low HP / high value targets
        score += target.value * 0.3
        score += (1 - target.hp_percentage) * 0.3

    # Personality modifiers
    if self.companion.personality.aggression > 70:
        score *= 1.2  # More aggressive targeting

    return score
```

### Combat System Integration

- Hook into existing combat turn system
- Respect action economy (action, bonus action, movement)
- Use existing dice rolling for attack/damage
- Update game state through standard combat tools

## Dependencies

- Task #42: Combat Agent (assumed to exist in Phase 3)
  - Requires combat state management
  - Uses combat action execution
- Task #54: Companion NPC Profiles
  - Requires CompanionProfile for archetype/personality data
  - Uses companion stats and abilities

## Effort Estimate

- **Size:** L
- **Estimated Hours:** 10
- **Complexity:** High - complex decision-making logic with many factors

## Definition of Done

1. TacticsEngine class fully implemented
2. All four archetype tactics working correctly
3. Target selection produces sensible choices
4. Ability selection respects resources and situation
5. Positioning logic accounts for battlefield state
6. Combat system integration complete
7. Personality influences visible in decisions
8. Unit tests cover all archetypes and edge cases
9. Integration tests with mock combat scenarios
10. Code reviewed and approved
