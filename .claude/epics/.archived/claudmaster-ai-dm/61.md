---
name: Split Party Handling
status: completed
created: 2026-02-05T19:06:45Z
updated: 2026-02-07T10:12:59Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/58
depends_on: [59, 60]
parallel: false
conflicts_with: []
---

# Split Party Handling

## Description

Implement sophisticated handling for split party scenarios where player characters separate into multiple groups operating in different locations simultaneously. This feature manages parallel scenes, context switching between groups, and eventual party reunification. Split party scenarios are common in D&D (stealth missions, research in different locations, prisoner rescue) and require careful orchestration to maintain narrative coherence.

## Acceptance Criteria

- [ ] Detect when party splits into separate groups
- [ ] Create and manage parallel scene contexts
- [ ] Implement context switching between active groups
- [ ] Handle time synchronization between groups
- [ ] Support reunification detection and handling
- [ ] Manage group-specific NPC interactions
- [ ] Handle cross-group communication (sending messages, etc.)
- [ ] Track location-specific state per group
- [ ] Create unit tests for split scenarios
- [ ] Document split party mechanics

## Technical Details

### PartyGroup Management

```python
@dataclass
class PartyGroup:
    """Represents a subset of the party operating together."""
    group_id: str
    member_ids: set[str]  # PC IDs
    location: str
    scene_context: SceneContext
    is_active: bool = True
    time_elapsed: timedelta = timedelta()
    pending_events: list[GameEvent] = field(default_factory=list)

class SplitPartyManager:
    """Manages split party scenarios."""

    def __init__(self, orchestrator: Orchestrator):
        self.orchestrator = orchestrator
        self.groups: dict[str, PartyGroup] = {}
        self.active_group_id: Optional[str] = None
        self.split_history: list[SplitEvent] = []

    def detect_split(self, action: str, pc_id: str) -> Optional[SplitProposal]:
        """Detect if an action would split the party."""
        pass

    def execute_split(self, departing_pcs: set[str], destination: str) -> PartyGroup:
        """Split specified PCs into a new group."""
        pass

    def get_group_for_pc(self, pc_id: str) -> Optional[PartyGroup]:
        """Find which group a PC belongs to."""
        pass

    def is_party_split(self) -> bool:
        """Check if party is currently split."""
        return len(self.groups) > 1
```

### Context Switching

```python
class SplitPartyManager:
    def switch_to_group(self, group_id: str) -> SceneContext:
        """Switch narrative focus to a different group."""
        # Save current group's context
        if self.active_group_id:
            self._save_group_context(self.active_group_id)

        # Load new group's context
        self.active_group_id = group_id
        group = self.groups[group_id]

        return self._build_transition_context(group)

    def _build_transition_context(self, group: PartyGroup) -> SceneContext:
        """Build context for transitioning to a group."""
        return SceneContext(
            location=group.location,
            participants=[self.orchestrator.get_pc_state(pc) for pc in group.member_ids],
            recent_events=group.pending_events[-5:],
            time_of_day=self._calculate_group_time(group),
            atmosphere=self._infer_atmosphere(group)
        )

    def get_switch_narration(self, from_group: str, to_group: str) -> str:
        """Generate transition narration between groups."""
        # "Meanwhile, back at the tavern..."
        # "Cutting to the infiltration team..."
        pass
```

### Time Synchronization

```python
@dataclass
class TimeSync:
    """Tracks time across split groups."""
    base_time: datetime
    group_offsets: dict[str, timedelta]
    sync_points: list[datetime]

class SplitPartyManager:
    def advance_group_time(self, group_id: str, duration: timedelta) -> None:
        """Advance time for a specific group."""
        pass

    def sync_all_groups(self) -> timedelta:
        """Synchronize all groups to the slowest timeline."""
        pass

    def get_time_differential(self, group_a: str, group_b: str) -> timedelta:
        """Calculate time difference between two groups."""
        pass

    def handle_time_sensitive_event(self, event: GameEvent) -> list[str]:
        """Handle events that affect multiple groups at specific times."""
        # e.g., alarm goes off affecting both stealth and distraction teams
        pass
```

### Reunification Handling

```python
@dataclass
class ReunificationEvent:
    """Details of party reunification."""
    groups_merged: list[str]
    location: str
    trigger: str  # What caused reunification
    time_adjustment: timedelta
    shared_discoveries: list[str]

class SplitPartyManager:
    def detect_reunification(self, action: str, pc_id: str) -> Optional[ReunificationEvent]:
        """Detect if an action would reunify groups."""
        pass

    def execute_reunification(self, groups_to_merge: list[str]) -> PartyGroup:
        """Merge groups back together."""
        # Combine member lists
        # Reconcile time differences
        # Merge scene contexts
        # Generate reunion narration
        pass

    def generate_catchup_summary(self, reunification: ReunificationEvent) -> str:
        """Generate summary of what each group experienced."""
        # "While you were gone, the stealth team discovered..."
        pass
```

### Cross-Group Communication

```python
class SplitPartyManager:
    def send_message(self, from_pc: str, to_pc: str, message: str) -> MessageResult:
        """Handle sending messages between groups (if possible)."""
        from_group = self.get_group_for_pc(from_pc)
        to_group = self.get_group_for_pc(to_pc)

        if from_group == to_group:
            return MessageResult(success=True, delay=timedelta())

        # Check communication methods (Sending spell, animal messenger, etc.)
        return self._attempt_cross_group_comm(from_pc, to_pc, message)

    def broadcast_event(self, event: GameEvent, affected_groups: list[str]) -> None:
        """Broadcast an event that affects multiple groups."""
        # e.g., earthquake, dragon attack on city
        pass
```

## Dependencies

- Task #58: Multiple PC Tracking
  - Requires PC registry
  - Requires per-PC state management
- Task #59: Turn Distribution and Management
  - Requires turn management for switching between groups
  - Requires understanding of game phases

## Effort Estimate

- **Size:** L
- **Estimated Hours:** 10
- **Complexity:** High - parallel state management with synchronization

## Definition of Done

1. Split detection working correctly
2. Parallel group management implemented
3. Context switching smooth and properly narrated
4. Time synchronization handles all edge cases
5. Reunification merges state correctly
6. Cross-group communication supported
7. All unit tests passing
8. Integration tests with complex split scenarios
9. Performance tested with multiple groups
10. Documentation complete with examples
11. Code reviewed and approved
