---
name: Module Fidelity Enforcement
status: completed
created: 2026-02-05T19:06:45Z
updated: 2026-02-07T09:23:03Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/50
depends_on: [51, 52, 49]
parallel: false
conflicts_with: []
---

# Module Fidelity Enforcement

## Description

Implement runtime enforcement mechanisms that ensure AI agents respect locked elements and module fidelity settings. This includes the Narrator's adherence to locked content, Module Keeper's deviation detection, warning systems for unauthorized improvisation, and forced module text injection for critical locked scenes.

## Acceptance Criteria

- [ ] Narrator agent respects locked elements during narration generation
- [ ] Module Keeper agent detects and flags deviations from locked content
- [ ] Implement warning system when AI improvises on locked content
- [ ] Create forced module text mechanism for locked scenes
- [ ] Add real-time fidelity checking during narration
- [ ] Implement correction suggestions when deviations detected
- [ ] Create audit log for all fidelity violations
- [ ] Include integration tests for enforcement scenarios

## Technical Details

### Narrator Lock Enforcement

```python
class NarratorLockEnforcer:
    """Enforces lock configuration during narration."""

    async def enforce_locks(
        self,
        generated_narration: str,
        context: NarrationContext,
        locks: LockConfiguration
    ) -> EnforcementResult:
        """Check narration against locks and enforce compliance."""
        violations = self._detect_violations(generated_narration, locks)
        if violations:
            return self._apply_corrections(generated_narration, violations)
        return EnforcementResult(narration=generated_narration, modified=False)
```

### Module Keeper Deviation Detection

```python
class DeviationDetector:
    """Detects deviations from locked module content."""

    def detect_deviations(
        self,
        narration: str,
        locked_elements: List[ElementLock],
        module_content: ModuleData
    ) -> List[Deviation]:
        """Compare narration against locked content for deviations."""
        deviations = []
        for lock in locked_elements:
            canonical = module_content.get_element(lock.element_id)
            similarity = self._calculate_similarity(narration, canonical)
            if similarity < lock.required_fidelity:
                deviations.append(Deviation(
                    element=lock,
                    expected=canonical,
                    actual=narration,
                    similarity=similarity
                ))
        return deviations
```

### Warning System

```python
@dataclass
class FidelityWarning:
    """Warning issued when locked content is improvised."""
    severity: Literal["info", "warning", "critical"]
    element: ElementLock
    deviation_type: str
    expected_content: str
    actual_content: str
    suggestion: str

class FidelityWarningSystem:
    """Manages warnings for fidelity violations."""

    def issue_warning(self, deviation: Deviation) -> FidelityWarning:
        """Create warning from detected deviation."""
        severity = self._determine_severity(deviation)
        return FidelityWarning(
            severity=severity,
            element=deviation.element,
            deviation_type=deviation.type,
            expected_content=deviation.expected,
            actual_content=deviation.actual,
            suggestion=self._generate_suggestion(deviation)
        )
```

### Forced Module Text

For critically locked scenes, bypass AI generation entirely:

```python
class ForcedTextInjector:
    """Injects canonical module text for locked scenes."""

    def should_force_text(self, context: NarrationContext, locks: LockConfiguration) -> bool:
        """Determine if scene requires forced module text."""
        return any(
            lock.is_locked and lock.force_canonical
            for lock in locks.get_applicable_locks(context)
        )

    def get_forced_text(self, context: NarrationContext, module: ModuleData) -> str:
        """Retrieve canonical text from module."""
        return module.get_boxed_text(context.scene_id)
```

### Audit Log

```python
@dataclass
class FidelityAuditEntry:
    """Audit log entry for fidelity events."""
    timestamp: datetime
    event_type: Literal["violation", "warning", "correction", "forced"]
    element_id: str
    details: dict
    session_id: str
```

## Dependencies

- Task 50: Improvisation Level System (provides level constraints)
- Task 51: Locked and Flexible Elements Configuration (provides lock config)
- Task 48: Module Keeper Agent (provides deviation detection capabilities)

## Effort Estimate

- **Size:** L
- **Estimated Hours:** 8
- **Complexity:** High - real-time enforcement with multiple integration points

## Definition of Done

1. Narrator correctly respects all locked elements
2. Module Keeper reliably detects deviations
3. Warning system issues appropriate alerts
4. Forced text mechanism works for locked scenes
5. Audit log captures all fidelity events
6. All code passes linting and type checking
7. Integration tests cover all enforcement scenarios
8. Performance acceptable (< 100ms enforcement overhead)
9. Documentation includes enforcement configuration guide
