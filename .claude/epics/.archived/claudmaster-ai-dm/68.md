---
name: Performance Optimization
status: completed
created: 2026-02-05T19:06:45Z
updated: 2026-02-07T10:56:49Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/65
depends_on: [34, 40, 43]
parallel: false
conflicts_with: []
---

# Performance Optimization

## Description

Implement performance optimizations to ensure the Claudmaster AI DM system provides responsive gameplay. This includes response time profiling, agent query parallelization, caching of frequently accessed module content, and lazy loading optimizations. The target is achieving sub-10-second p95 response times for player actions.

## Acceptance Criteria

- [ ] Implement response time profiling and metrics collection
- [ ] Parallelize independent agent queries
- [ ] Cache frequently used module content
- [ ] Implement lazy loading for non-critical data
- [ ] Optimize context building for minimal latency
- [ ] Profile and optimize hot paths
- [ ] Achieve <10s p95 response time target
- [ ] Add performance benchmarks
- [ ] Create performance monitoring dashboard/logs
- [ ] Document performance tuning options

## Technical Details

### Performance Profiler

```python
class PerformanceProfiler:
    """Tracks and reports performance metrics."""

    def __init__(self):
        self.metrics: dict[str, list[float]] = defaultdict(list)
        self.active_traces: dict[str, float] = {}

    @contextmanager
    def trace(self, operation: str):
        """Context manager for timing operations."""
        start = time.perf_counter()
        try:
            yield
        finally:
            duration = time.perf_counter() - start
            self.metrics[operation].append(duration)

    def get_percentile(self, operation: str, percentile: float) -> float:
        """Get percentile timing for operation (e.g., p95)."""

    def get_report(self) -> PerformanceReport:
        """Generate comprehensive performance report."""

    def identify_bottlenecks(self) -> list[str]:
        """Identify operations exceeding thresholds."""
```

### Agent Parallelization

```python
class ParallelAgentExecutor:
    """Executes independent agent queries in parallel."""

    def __init__(self, orchestrator: Orchestrator):
        self.orchestrator = orchestrator
        self.max_concurrent = 4

    async def execute_parallel(
        self,
        requests: list[AgentRequest]
    ) -> list[AgentResponse]:
        """
        Execute multiple agent requests in parallel.

        Groups requests by dependency and executes independent
        requests concurrently while respecting dependencies.
        """

    def analyze_dependencies(
        self,
        requests: list[AgentRequest]
    ) -> list[list[AgentRequest]]:
        """Group requests into parallel execution batches."""

    async def execute_with_timeout(
        self,
        request: AgentRequest,
        timeout: float
    ) -> AgentResponse:
        """Execute single request with timeout."""
```

### Module Content Cache

```python
class ModuleCache:
    """Caches frequently accessed module content."""

    def __init__(
        self,
        max_size_mb: int = 50,
        ttl_minutes: int = 30
    ):
        self.cache: dict[str, CacheEntry] = {}
        self.max_size = max_size_mb * 1024 * 1024
        self.ttl = ttl_minutes * 60
        self.access_counts: dict[str, int] = Counter()

    def get(self, key: str) -> Optional[Any]:
        """Get cached item if valid."""

    def put(self, key: str, value: Any, size: int) -> None:
        """Cache item with LRU eviction."""

    def preload(self, module: Module, priority_keys: list[str]) -> None:
        """Preload high-priority content into cache."""

    def invalidate_pattern(self, pattern: str) -> int:
        """Invalidate cache entries matching pattern."""

    def get_stats(self) -> CacheStats:
        """Return cache hit/miss statistics."""
```

### Lazy Loading Manager

```python
class LazyLoadManager:
    """Manages lazy loading of non-critical data."""

    def __init__(self, module: Module):
        self.module = module
        self.loaded: set[str] = set()
        self.loading: set[str] = set()

    def ensure_loaded(self, *sections: str) -> None:
        """Ensure specified sections are loaded."""

    async def load_background(self, section: str) -> None:
        """Load section in background without blocking."""

    def get_load_priority(self, action_type: str) -> list[str]:
        """Determine what to preload based on likely next actions."""
```

### Context Building Optimization

```python
class OptimizedContextBuilder:
    """Builds context with performance optimizations."""

    def __init__(
        self,
        context_manager: ContextWindowManager,
        cache: ModuleCache
    ):
        self.context_manager = context_manager
        self.cache = cache

    async def build_context(
        self,
        request: AgentRequest,
        budget: int
    ) -> str:
        """
        Build context efficiently.

        Optimizations:
        1. Use cached content when available
        2. Prioritize most relevant content first
        3. Stop early when budget is reached
        4. Parallelize content retrieval
        """

    def estimate_relevance(
        self,
        content: str,
        request: AgentRequest
    ) -> float:
        """Quick relevance estimation without full processing."""
```

### Performance Targets

| Operation | Target p50 | Target p95 | Target p99 |
|-----------|------------|------------|------------|
| player_action (total) | 3s | 10s | 15s |
| Context building | 500ms | 1.5s | 3s |
| Agent query (single) | 1s | 3s | 5s |
| State update | 100ms | 300ms | 500ms |
| Cache lookup | 5ms | 20ms | 50ms |

### Configuration

```yaml
# In claudmaster_config.yaml
performance:
  profiling:
    enabled: true
    sample_rate: 1.0  # 100% in dev, lower in prod
  parallelization:
    max_concurrent_agents: 4
    agent_timeout_seconds: 5
  cache:
    max_size_mb: 50
    ttl_minutes: 30
    preload_enabled: true
  lazy_loading:
    enabled: true
    background_load: true
```

### File Structure

```
src/gamemaster_mcp/claudmaster/
├── performance/
│   ├── __init__.py
│   ├── profiler.py           # PerformanceProfiler
│   ├── parallel_executor.py  # ParallelAgentExecutor
│   ├── cache.py              # ModuleCache
│   ├── lazy_load.py          # LazyLoadManager
│   └── context_optimizer.py  # OptimizedContextBuilder
```

### Benchmarking

```python
class PerformanceBenchmark:
    """Runs performance benchmarks for the system."""

    async def run_benchmarks(self) -> BenchmarkResults:
        """Run full benchmark suite."""

    async def benchmark_action_processing(
        self,
        iterations: int = 100
    ) -> list[float]:
        """Benchmark player action processing times."""

    async def benchmark_context_building(
        self,
        iterations: int = 100
    ) -> list[float]:
        """Benchmark context building times."""

    def compare_to_targets(
        self,
        results: BenchmarkResults
    ) -> list[str]:
        """Compare results to performance targets."""
```

## Dependencies

- Task #33: Orchestrator Skeleton (for agent coordination)
- Task #39: Module Loader Implementation (for module content loading)
- Task #42: Semantic Chunking for Modules (for optimized content retrieval)

## Effort Estimate

- **Size:** L
- **Estimated Hours:** 10
- **Complexity:** High - system-wide optimization and profiling

## Definition of Done

1. Performance profiler implemented and integrated
2. Agent parallelization working correctly
3. Module cache implemented with LRU eviction
4. Lazy loading system functional
5. Context building optimized
6. All hot paths profiled and optimized
7. p95 response time <10s achieved in benchmarks
8. Performance monitoring/logging in place
9. Benchmark suite created and documented
10. Performance configuration options documented
11. Unit tests for all optimization components
12. Load tests demonstrating target performance
