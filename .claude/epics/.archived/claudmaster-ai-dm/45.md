---
name: Combat Narration System
status: completed
created: 2026-02-05T19:06:45Z
updated: 2026-02-05T19:21:30Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/42
depends_on: [35, 43]
parallel: true
conflicts_with: []
---

# Combat Narration System

## Description

Implement a combat narration system that generates engaging descriptions for combat rounds, attacks, damage, spell effects, and dramatic moments like death and unconsciousness. This system transforms mechanical combat results into vivid narrative prose while maintaining accuracy to the game mechanics.

## Acceptance Criteria

- [ ] Generate combat round descriptions with initiative tracking
- [ ] Narrate attack rolls with hit/miss descriptions
- [ ] Describe damage with appropriate severity language
- [ ] Create spell effect descriptions matching spell flavor
- [ ] Handle death and unconsciousness with dramatic narration
- [ ] Support critical hits and fumbles with special descriptions
- [ ] Vary descriptions to avoid repetition
- [ ] Maintain combat pacing through narration style
- [ ] Create unit tests for all narration types
- [ ] Add integration tests with combat state

## Technical Details

### CombatNarrator Class

```python
class CombatNarrator:
    """Generates narrative descriptions for combat events."""

    def __init__(self, narrator_agent: NarratorAgent, archivist: ArchivistAgent):
        self.narrator = narrator_agent
        self.archivist = archivist
        self._description_history: list[str] = []

    async def narrate_round_start(
        self,
        round_number: int,
        initiative_order: list[InitiativeEntry]
    ) -> str:
        """Describe the start of a new combat round."""
        pass

    async def narrate_attack(
        self,
        attacker: str,
        defender: str,
        weapon: str,
        roll: int,
        hit: bool,
        critical: bool = False,
        fumble: bool = False
    ) -> str:
        """Narrate an attack attempt."""
        pass

    async def narrate_damage(
        self,
        target: str,
        damage: int,
        damage_type: str,
        current_hp: int,
        max_hp: int
    ) -> str:
        """Describe damage dealt to a target."""
        pass

    async def narrate_spell(
        self,
        caster: str,
        spell: SpellInfo,
        targets: list[str],
        effects: list[SpellEffect]
    ) -> str:
        """Describe a spell being cast and its effects."""
        pass

    async def narrate_death(
        self,
        character: str,
        killing_blow: str,
        is_player: bool
    ) -> str:
        """Narrate a character's death dramatically."""
        pass

    async def narrate_unconscious(
        self,
        character: str,
        cause: str
    ) -> str:
        """Describe a character falling unconscious."""
        pass
```

### Damage Severity Descriptions

```python
class DamageSeverity(Enum):
    SCRATCH = "scratch"      # < 10% max HP
    LIGHT = "light"          # 10-25% max HP
    MODERATE = "moderate"    # 25-50% max HP
    HEAVY = "heavy"          # 50-75% max HP
    DEVASTATING = "devastating"  # > 75% max HP

def get_damage_severity(damage: int, max_hp: int) -> DamageSeverity:
    """Determine damage severity for narration."""
    percentage = damage / max_hp
    if percentage < 0.10:
        return DamageSeverity.SCRATCH
    elif percentage < 0.25:
        return DamageSeverity.LIGHT
    # ... etc
```

### Attack Description Templates

Maintain variety with contextual templates:
```python
MELEE_HIT_TEMPLATES = [
    "{attacker}'s {weapon} finds its mark, striking {defender}",
    "With a swift motion, {attacker} lands a blow on {defender}",
    "{defender} fails to parry as {attacker}'s {weapon} connects",
    # ... more templates
]

CRITICAL_HIT_TEMPLATES = [
    "{attacker} finds a gap in {defender}'s defenses, striking a devastating blow!",
    "A perfect strike! {attacker}'s {weapon} hits {defender} in a vital spot!",
    # ... more templates
]
```

### Spell Effect Descriptions

Map spell schools to descriptive styles:
```python
SPELL_SCHOOL_FLAVORS = {
    "evocation": {
        "fire": ["flames erupt", "fire engulfs", "blazing heat"],
        "cold": ["frost spreads", "ice crystallizes", "bitter cold"],
        "lightning": ["electricity arcs", "thunder cracks", "lightning strikes"]
    },
    "necromancy": {
        "damage": ["dark energy drains", "life force withers", "shadow claws"],
        "healing": ["wounds close unnaturally", "flesh knits together"]
    },
    # ... etc
}
```

### Death and Unconsciousness

```python
@dataclass
class DramaticMoment:
    character: str
    event_type: str  # "death", "unconscious", "stabilized"
    context: str
    witness_reactions: list[str]
    mechanical_result: str
```

Handle with appropriate gravity:
- Player death: Extended, dramatic description with party reaction
- NPC death: Contextual based on importance
- Monster death: Brief but satisfying
- Unconscious: Tense, maintaining hope

### Repetition Avoidance

```python
class DescriptionTracker:
    """Track recent descriptions to avoid repetition."""

    def __init__(self, history_size: int = 20):
        self.history: deque[str] = deque(maxlen=history_size)
        self.template_usage: dict[str, int] = {}

    def is_too_similar(self, new_description: str) -> bool:
        """Check if description is too similar to recent ones."""
        pass

    def get_least_used_template(self, templates: list[str]) -> str:
        """Select template that hasn't been used recently."""
        pass
```

## Dependencies

- Task 34: Narrative Engine Architecture
- Task 42: Archivist Agent Implementation

## Effort Estimate

- **Size:** M
- **Estimated Hours:** 6
- **Complexity:** Medium - creative writing generation with mechanical accuracy

## Definition of Done

1. CombatNarrator class fully implemented
2. All narration methods generating quality output
3. Damage severity correctly mapped to descriptions
4. Spell effects properly flavored by school
5. Critical hits and fumbles have special narration
6. Death/unconsciousness handled dramatically
7. Repetition avoidance working
8. All unit tests passing
9. Integration tests with combat state passing
10. Documentation complete with examples
11. Code reviewed and approved
