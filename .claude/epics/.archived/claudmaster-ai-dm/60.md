---
name: Turn Distribution and Management
status: completed
created: 2026-02-05T19:06:45Z
updated: 2026-02-07T09:23:03Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/57
depends_on: [34, 59]
parallel: false
conflicts_with: []
---

# Turn Distribution and Management

## Description

Implement a comprehensive turn management system for multi-player sessions that handles both combat and non-combat scenarios. This system integrates with the existing initiative mechanics for combat while providing flexible turn handling for exploration and roleplay phases. The system must fairly distribute player turns and handle edge cases like simultaneous actions and player timeouts.

## Acceptance Criteria

- [ ] Implement turn order management for multiple players
- [ ] Integrate with existing combat initiative system
- [ ] Handle out-of-combat turn distribution (round-robin, free-form)
- [ ] Support simultaneous action resolution
- [ ] Implement turn timeout handling
- [ ] Track turn history for context
- [ ] Handle held/delayed actions
- [ ] Support interrupt mechanics
- [ ] Create unit tests for turn management
- [ ] Document turn flow for different game phases

## Technical Details

### TurnManager Class

```python
class TurnPhase(Enum):
    COMBAT = "combat"
    EXPLORATION = "exploration"
    ROLEPLAY = "roleplay"
    DOWNTIME = "downtime"

@dataclass
class TurnState:
    """Current state of turn management."""
    phase: TurnPhase
    current_round: int
    current_pc_id: Optional[str]
    turn_order: list[str]  # Character/NPC IDs
    held_actions: dict[str, str]  # PC ID -> action description
    completed_turns: set[str]
    round_start_time: datetime

class TurnManager:
    """Manages turn distribution across players."""

    def __init__(self, orchestrator: Orchestrator):
        self.orchestrator = orchestrator
        self.state: TurnState = None
        self.turn_history: list[TurnRecord] = []

    def start_round(self, phase: TurnPhase) -> TurnState:
        """Begin a new round of turns."""
        pass

    def get_current_turn(self) -> str:
        """Get the ID of whose turn it is."""
        pass

    def advance_turn(self) -> str:
        """Move to the next turn in order."""
        pass

    def hold_action(self, pc_id: str, trigger: str) -> None:
        """PC holds their action for a trigger."""
        pass

    def resolve_held_action(self, pc_id: str) -> Optional[str]:
        """Resolve a held action when triggered."""
        pass

    def handle_simultaneous(self, actions: list[tuple[str, str]]) -> list[ActionResult]:
        """Resolve multiple simultaneous actions."""
        pass
```

### Initiative Integration

```python
class TurnManager:
    def build_combat_order(self, participants: list[str]) -> list[str]:
        """Build turn order from initiative rolls."""
        # Get initiative from existing combat system
        combat_state = self.orchestrator.campaign.game_state.combat
        return sorted(
            participants,
            key=lambda p: combat_state.get_initiative(p),
            reverse=True
        )

    def insert_into_initiative(self, character_id: str, initiative: int) -> None:
        """Insert a new participant into existing initiative order."""
        pass
```

### Out-of-Combat Turn Handling

```python
class TurnDistribution(Enum):
    ROUND_ROBIN = "round_robin"  # Strict turn order
    FREE_FORM = "free_form"       # Anyone can act
    SPOTLIGHT = "spotlight"       # DM assigns focus
    POPCORN = "popcorn"          # Current player chooses next

class TurnManager:
    def set_distribution_mode(self, mode: TurnDistribution) -> None:
        """Set how turns are distributed out of combat."""
        pass

    def can_act(self, pc_id: str) -> bool:
        """Check if a PC can currently take an action."""
        pass
```

### Simultaneous Action Resolution

```python
@dataclass
class SimultaneousAction:
    pc_id: str
    action: str
    target: Optional[str]
    priority: int  # For ordering when needed

class TurnManager:
    def queue_simultaneous(self, pc_id: str, action: str) -> None:
        """Queue an action for simultaneous resolution."""
        pass

    def resolve_simultaneous_batch(self) -> list[ActionResult]:
        """Resolve all queued simultaneous actions."""
        # Handle conflicts (same target, opposing actions)
        # Apply effects in logical order
        # Return results for narration
        pass
```

### Timeout Handling

```python
class TurnManager:
    def check_timeout(self) -> Optional[str]:
        """Check if current turn has timed out."""
        if self.state.current_pc_id:
            elapsed = datetime.now() - self.state.turn_start_time
            if elapsed.seconds > self.config.turn_timeout_seconds:
                return self.state.current_pc_id
        return None

    def handle_timeout(self, pc_id: str) -> None:
        """Handle a player timeout - auto-pass or delay."""
        pass
```

## Dependencies

- Task #33: Orchestrator Skeleton
  - Requires base Orchestrator class
  - Requires game state integration
- Task #58: Multiple PC Tracking
  - Requires PC registry
  - Requires PC state management

## Effort Estimate

- **Size:** M
- **Estimated Hours:** 8
- **Complexity:** Medium-High - multiple game phases with different rules

## Definition of Done

1. TurnManager class fully implemented
2. Combat initiative integration working
3. Multiple turn distribution modes supported
4. Simultaneous actions resolve correctly
5. Timeout handling in place
6. Turn history tracked
7. Held actions work correctly
8. All unit tests passing
9. Integration tests with combat scenarios
10. Documentation complete with examples
11. Code reviewed and approved
