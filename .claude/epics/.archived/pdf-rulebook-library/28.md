---
name: RulebookManager integration - load extracted content as CustomSource
status: completed
created: 2026-02-02T20:05:44Z
updated: 2026-02-02T20:11:56Z
github: https://github.com/Polloinfilzato/gamemaster-mcp/issues/28
depends_on: [25, 27]
parallel: false
conflicts_with: []
---

# Task: RulebookManager integration - load extracted content as CustomSource

## Description

Integrate the library system with `RulebookManager` so that enabled library content appears in `search_rules`, `get_class_info`, etc. Extracted content is loaded as `CustomSource` instances, reusing the existing infrastructure.

## Acceptance Criteria

- [ ] Load enabled library content as `CustomSource` when campaign loads
- [ ] Library content appears in `search_rules` results
- [ ] `get_class_info` returns library class details
- [ ] `get_race_info` returns library race details
- [ ] `get_spell_info` returns library spell details
- [ ] `get_monster_info` returns library monster details
- [ ] Library sources have lower priority than explicit custom sources
- [ ] Automatic reload when bindings change
- [ ] Unit tests for integration

## Technical Details

### Files to Modify

```
src/gamemaster_mcp/
├── storage.py          # UPDATE: Load library content with campaign
└── library/
    └── manager.py      # UPDATE: Method to load as CustomSource
```

### LibraryManager Extension

```python
class LibraryManager:
    # ... existing methods ...

    def get_custom_sources_for_campaign(
        self,
        bindings: LibraryBindings
    ) -> list[tuple[str, CustomSource]]:
        """
        Get CustomSource instances for enabled library content.

        Returns list of (source_id, CustomSource) tuples.
        """
        sources = []
        for source_id in bindings.get_enabled_sources():
            extracted_dir = self.extracted_dir / source_id
            if not extracted_dir.exists():
                continue

            # Collect all extracted JSON files for this source
            for json_file in extracted_dir.glob("*.json"):
                custom_source = CustomSource(
                    source_id=f"library:{source_id}:{json_file.stem}",
                    path=json_file
                )
                sources.append((source_id, custom_source))

        return sources

    def create_aggregate_source(
        self,
        source_id: str,
        bindings: LibraryBindings
    ) -> CustomSource | None:
        """
        Create a single CustomSource containing all enabled content from a library source.

        This aggregates multiple extracted files into one source for cleaner management.
        """
        extracted_dir = self.extracted_dir / source_id
        if not extracted_dir.exists():
            return None

        binding = bindings.sources.get(source_id)
        if not binding or not binding.enabled:
            return None

        # Aggregate content
        aggregated = {
            "$schema": "gamemaster-mcp/rulebook-v1",
            "name": f"Library: {source_id}",
            "version": "aggregated",
            "content": {
                "classes": [],
                "races": [],
                "spells": [],
                "monsters": [],
                "feats": [],
                "items": [],
            }
        }

        for json_file in extracted_dir.glob("*.json"):
            data = json.loads(json_file.read_text())
            content = data.get("content", {})

            # Apply content filter
            for content_type, items in content.items():
                if self._is_content_enabled(binding, content_type, items):
                    aggregated["content"][content_type].extend(items)

        # Create temp file and CustomSource
        return CustomSource.from_dict(f"library:{source_id}", aggregated)
```

### Storage Integration

```python
# In DnDStorage._load_campaign()

async def _load_library_content(self) -> None:
    """Load enabled library content into RulebookManager."""
    if not self._library_manager or not self._rulebook_manager:
        return

    bindings = self._load_library_bindings()
    if not bindings:
        return

    for source_id in bindings.get_enabled_sources():
        custom_source = self._library_manager.create_aggregate_source(
            source_id, bindings
        )
        if custom_source:
            await custom_source.load()
            await self._rulebook_manager.load_source(custom_source)
```

### Priority Handling

Library sources should be loaded with lower priority than:
1. SRD (if loaded)
2. Explicit custom rulebooks

```python
# In RulebookManager
def _get_library_priority_position(self) -> int:
    """Library content goes between SRD and custom sources."""
    # Find position after SRD, before custom
    for i, source_id in enumerate(self._priority):
        if source_id.startswith("custom:"):
            return i
    return len(self._priority)
```

### Manifest Update

Update `manifest.json` to track library sources:

```json
{
  "active_sources": {
    "srd_2014": {...},
    "library:tome-of-heroes": {
      "type": "library",
      "source_id": "tome-of-heroes",
      "loaded_at": "2026-02-02T16:00:00Z"
    },
    "custom:homebrew": {...}
  },
  "priority": ["srd_2014", "library:tome-of-heroes", "custom:homebrew"]
}
```

## Dependencies

- [ ] Task #24 (Content extraction produces CustomSource-compatible files)
- [ ] Task #26 (Bindings determine what to load)

## Effort Estimate

- Size: M
- Hours: 4-6
- Parallel: false (depends on extraction and bindings)

## Definition of Done

- [ ] Enabled library content auto-loads with campaign
- [ ] Library content searchable via `search_rules`
- [ ] Library classes/races/spells accessible via get_*_info tools
- [ ] Priority correctly positions library between SRD and custom
- [ ] Content filter respected (only enabled items loaded)
- [ ] Unit tests for full integration path
- [ ] Integration tests with real campaign
