---
name: WebSocket Real-Time Push
status: open
created: 2026-02-17T16:54:33Z
updated: 2026-02-17T17:07:59Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/154
depends_on: [149, 150, 151]
parallel: false
conflicts_with: []
---

# Task: WebSocket Real-Time Push

## Description

Wire the response queue to WebSocket broadcast so that when the host processes a player action, all connected browsers receive the appropriate filtered response in real-time. This is the integration task that connects the backend pipeline (Task #150) to the frontend UI (Task #151).

Each connected player receives a **personalized view** of each response: public narrative goes to all, private information goes only to the intended recipient, DM-only content is stripped entirely.

## Acceptance Criteria

- [ ] When a response is added to `ResponseQueue`, all connected WebSocket clients receive their filtered version
- [ ] Filtering uses `bridge.format_response()` which applies `PermissionResolver` + `OutputFilter`
- [ ] Player A's private info is never sent to Player B's WebSocket
- [ ] DM-only content is never sent to any player WebSocket
- [ ] OBSERVER connections receive only public narrative (no private messages, no character data)
- [ ] Player connection events broadcast to all: "{Player} joined" / "{Player} disconnected"
- [ ] On WebSocket reconnect, player receives missed messages since their last-seen timestamp
- [ ] Message replay uses `ResponseQueue.get_for_player(player_id, since_timestamp)` with permission filtering
- [ ] Character update events pushed when `get_character` data changes (HP, conditions, inventory)
- [ ] Combat state events pushed when turn changes (active player, initiative order)
- [ ] WebSocket heartbeat (ping/pong every 30s) to detect stale connections
- [ ] Stale connections cleaned up after 60s of no pong
- [ ] Multiple tabs from same player all receive updates
- [ ] Integration test: 3 simulated players, submit action, verify each receives correct filtered response
- [ ] Permission boundary test: verify Player A never receives Player B's private content across 100 messages

## Technical Details

### Modified Files

```
src/dm20_protocol/party/
├── server.py      # Add broadcast_to_player(), broadcast_to_all(), handle_reconnect()
├── queue.py       # Add on_response callback, last_seen tracking per player
└── bridge.py      # Add get_combat_state(), character change detection
```

### Broadcast Architecture

```python
# In server.py
class ConnectionManager:
    connections: dict[str, set[WebSocket]]  # player_id → set of WebSocket connections
    last_seen: dict[str, datetime]          # player_id → last message timestamp

    async def broadcast_response(self, response: dict):
        """Push response to all connected players with per-player filtering."""
        for player_id, sockets in self.connections.items():
            filtered = bridge.format_response(response, player_id)
            for ws in sockets:
                await ws.send_json(filtered)

    async def send_to_player(self, player_id: str, message: dict):
        """Send a message to a specific player (all their tabs)."""
        for ws in self.connections.get(player_id, set()):
            await ws.send_json(message)

    async def handle_reconnect(self, player_id: str, since: datetime):
        """Replay missed messages since last-seen timestamp."""
        missed = response_queue.get_for_player(player_id, since)
        for msg in missed:
            await self.send_to_player(player_id, msg)
```

### Push Trigger

The response queue has an `on_push` callback. When `ResponseQueue.push(response)` is called (by `/dm:party-next` or `/dm:party-auto`), it triggers:

```python
async def on_response_pushed(response):
    await connection_manager.broadcast_response(response)
    # Also push character updates if HP/conditions changed
    for player_id in affected_players(response):
        char_data = bridge.get_character_view(player_id)
        await connection_manager.send_to_player(player_id, {
            "type": "character_update",
            "data": char_data
        })
```

### Reconnection Protocol

1. Client reconnects with WebSocket
2. Sends `{ type: "auth", token: "xxx", last_seen: "2026-02-17T20:15:00Z" }`
3. Server validates token, looks up `last_seen`
4. Replays all filtered responses since `last_seen`
5. Client catches up without missing any narrative

### Heartbeat

- Server sends `ping` every 30 seconds
- Client responds with `pong`
- If no `pong` received within 60 seconds, connection is marked stale and cleaned up
- Client-side: if no `ping` received in 45 seconds, assume disconnected and attempt reconnect

## Dependencies

- [ ] Task #149 (Web Server Core) — WebSocket connection manager
- [ ] Task #150 (Action Queue) — ResponseQueue with on_push callback, bridge.format_response()
- [ ] Task #151 (Player Web UI) — WebSocket client in app.js handles incoming messages

## Effort Estimate

- Size: M
- Hours: 6-8h
- Parallel: false (requires Tasks 149-151 to be complete)

## Definition of Done

- [ ] Responses push to all connected browsers in real-time (< 500ms latency on LAN)
- [ ] Per-player filtering verified: no private info leakage
- [ ] Reconnection replays missed messages correctly
- [ ] Heartbeat detects and cleans up stale connections
- [ ] Works with 6+ concurrent WebSocket connections
- [ ] All integration and permission tests pass
