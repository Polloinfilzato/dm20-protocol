---
name: End-to-End Integration Testing
status: open
created: 2026-02-17T16:54:33Z
updated: 2026-02-17T17:07:59Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/157
depends_on: [149, 150, 151, 152, 153, 154]
parallel: false
conflicts_with: []
---

# Task: End-to-End Integration Testing

## Description

Comprehensive testing of the entire Party Mode system with simulated multi-player scenarios. Verifies that all components work together: web server, authentication, action queues, WebSocket push, permission filtering, combat coordination, and slash commands.

This task focuses on integration and edge-case testing that individual task tests don't cover — particularly around **permission boundaries** (no private info leakage) and **concurrency** (multiple players acting simultaneously).

## Acceptance Criteria

- [ ] **Multi-player simulation**: test with 4 simulated players connecting via WebSocket
- [ ] **Full action cycle**: player submits action → queue → host processes → response → WebSocket push → player receives
- [ ] **Permission boundary tests**: across 100 messages, Player A never receives Player B's private content
- [ ] **Observer isolation**: OBSERVER connection never receives private messages, character data, or DM-only content
- [ ] **Concurrent actions**: 4 players submit actions simultaneously — all queue correctly, no data corruption
- [ ] **Reconnection test**: player disconnects, misses 5 messages, reconnects — receives all missed messages in order
- [ ] **Token security**: invalid token rejected on all endpoints (HTTP and WebSocket)
- [ ] **Token refresh**: old token stops working after refresh, new token works
- [ ] **Kick test**: kicked player's WebSocket closes, token rejected, other players unaffected
- [ ] **Combat lifecycle**: start combat → initiative display → turn gating → turn advance → combat end
- [ ] **Simultaneous combat**: trigger simultaneous round → all players submit → all collected → resolved
- [ ] **Character update propagation**: HP change via MCP tool → WebSocket push → all browsers update
- [ ] **MCP non-interference**: run MCP tool calls while web server is active — no interference
- [ ] **Session stability**: 30-minute simulated session with continuous actions — no memory leaks, no crashes
- [ ] **Queue persistence**: restart web server mid-session — pending actions survive, resolved history intact
- [ ] **Slash commands**: all `/dm:party-*` commands work correctly in sequence

## Technical Details

### New Files

```
tests/party/
├── __init__.py
├── test_e2e_party.py           # Full end-to-end scenarios
├── test_permission_boundary.py  # Permission isolation tests
├── test_concurrency.py          # Concurrent access tests
├── conftest.py                  # Shared fixtures: server, clients, mock campaign
└── helpers.py                   # SimulatedPlayer class, assertion helpers
```

### Test Infrastructure

```python
# conftest.py
@pytest.fixture
async def party_server():
    """Start Party Mode server on a random port for testing."""
    port = random_available_port()
    server = start_party_server(port=port, host="127.0.0.1")
    yield server
    stop_party_server()

@pytest.fixture
async def players(party_server):
    """Create 4 simulated players with WebSocket connections."""
    tokens = generate_tokens(mock_pc_registry)
    clients = []
    for player_id, token in tokens.items():
        ws = await websocket_connect(f"ws://127.0.0.1:{port}/ws")
        await ws.send_json({"type": "auth", "token": token})
        clients.append(SimulatedPlayer(player_id, token, ws))
    yield clients
    for c in clients:
        await c.ws.close()
```

### Key Test Scenarios

#### Scenario 1: Full Session Flow
```
1. Start Party Mode with 4 PCs
2. All 4 players connect via WebSocket
3. Player 1 submits action "I search the room"
4. Host processes via party-next
5. Verify: Player 1 receives public narrative + private perception result
6. Verify: Players 2-4 receive only public narrative
7. Verify: No DM-only content in any player's response
```

#### Scenario 2: Permission Stress Test
```
1. Generate 100 actions with mixed private content
2. Process all through the pipeline
3. For each player: assert they ONLY received their own private content
4. For OBSERVER: assert they received ZERO private content
5. Aggregate: zero permission violations across all messages
```

#### Scenario 3: Concurrent Submission
```
1. 4 players submit actions within 10ms of each other
2. All 4 actions appear in queue with unique IDs
3. No data corruption (each action has correct player_id)
4. Process all 4 in sequence — all resolve correctly
```

#### Scenario 4: Reconnection Replay
```
1. Player 1 is connected, receives 5 messages
2. Player 1 disconnects
3. 5 more messages are broadcast
4. Player 1 reconnects with last_seen timestamp
5. Player 1 receives exactly the 5 missed messages (filtered)
6. Player 1 continues receiving new messages normally
```

### Mock Campaign Setup

Tests use a mock campaign with:
- 4 PCs: Thorin (fighter), Elara (wizard), Vex (rogue), Gorm (cleric)
- 2 NPCs: tavern keeper (public), BBEG (DM-only bio)
- 1 location with discovery state
- Pre-set private info: Thorin has a secret background, Elara has a hidden roll

## Dependencies

- [ ] All previous tasks (#149-#154) must be complete
- [ ] `pytest-asyncio` for async test support (already a dev dependency)

## Effort Estimate

- Size: M
- Hours: 6-8h
- Parallel: false (requires all components to be complete)

## Definition of Done

- [ ] All test scenarios pass
- [ ] Zero permission boundary violations
- [ ] Concurrent access works without data corruption
- [ ] Reconnection replays missed messages correctly
- [ ] 30-minute stability test completes without errors
- [ ] All tests run in CI (no manual steps required)
