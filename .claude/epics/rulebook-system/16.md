---
name: Storage Integration
status: completed
created: 2026-02-02T03:47:06Z
updated: 2026-02-02T03:47:06Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/16
depends_on: [15]
parallel: true
conflicts_with: [16]
---

# Task: Storage Integration

## Description

Integrate the RulebookManager with the existing storage system. Add rulebook directory support to split-storage campaigns and connect the manager lifecycle to campaign load/unload.

## Acceptance Criteria

- [ ] Add `rulebooks_dir` property to DnDStorage for current campaign
- [ ] Create rulebooks directory structure on new campaign creation
- [ ] Load RulebookManager when campaign is loaded
- [ ] Expose manager via `storage.rulebook_manager` property
- [ ] Handle campaigns without rulebooks gracefully (backward compatible)
- [ ] Global cache directory at `dnd_data/rulebook_cache/` for shared SRD data

## Technical Details

### Storage Changes

```python
# In storage.py

class DnDStorage:
    def __init__(self, data_dir: str | Path = "dnd_data"):
        self.data_dir = Path(data_dir)
        self._current_campaign: Campaign | None = None
        self._rulebook_manager: RulebookManager | None = None

    @property
    def rulebook_manager(self) -> RulebookManager | None:
        """Get rulebook manager for current campaign."""
        return self._rulebook_manager

    @property
    def rulebooks_dir(self) -> Path | None:
        """Get rulebooks directory for current campaign (split storage only)."""
        if self._current_campaign and self._current_format == StorageFormat.SPLIT:
            return self._campaign_dir / "rulebooks"
        return None

    @property
    def rulebook_cache_dir(self) -> Path:
        """Global cache directory for rulebook data."""
        return self.data_dir / "rulebook_cache"
```

### Campaign Load Integration

```python
async def load_campaign(self, name: str) -> Campaign:
    campaign = self._load_campaign_data(name)
    self._current_campaign = campaign

    # Load rulebook manager if manifest exists
    if self.rulebooks_dir and (self.rulebooks_dir / "manifest.json").exists():
        self._rulebook_manager = await RulebookManager.from_manifest(
            self.rulebooks_dir,
            cache_dir=self.rulebook_cache_dir
        )
    else:
        self._rulebook_manager = None

    return campaign
```

### Directory Structure

```
dnd_data/
├── rulebook_cache/           # Global, shared across campaigns
│   └── srd_2014/
│       ├── classes/
│       ├── races/
│       ├── spells/
│       └── monsters/
└── campaigns/
    └── {campaign}/
        ├── campaign.json
        ├── characters.json
        └── rulebooks/        # Per-campaign
            ├── manifest.json
            └── custom/
                └── homebrew.json
```

### New Campaign Creation

```python
def create_campaign(self, name: str, ...) -> Campaign:
    # Existing logic...

    # Create rulebooks directory for split storage
    if self._current_format == StorageFormat.SPLIT:
        rulebooks_dir = self._campaign_dir / "rulebooks"
        rulebooks_dir.mkdir(exist_ok=True)
        (rulebooks_dir / "custom").mkdir(exist_ok=True)

    return campaign
```

## Dependencies

- [ ] Task 14: RulebookManager (must have manager to integrate)

## Effort Estimate

- Size: S
- Parallel: true (can run with Task 16)

## Definition of Done

- [ ] `rulebooks_dir` property works for split campaigns
- [ ] `rulebook_cache_dir` property points to global cache
- [ ] Campaign load initializes manager from manifest
- [ ] New campaigns create rulebooks directory
- [ ] Backward compatible: campaigns without rulebooks work
- [ ] Unit tests for new storage properties
