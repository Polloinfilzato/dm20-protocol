---
name: MCP Tools - Rule Queries
status: completed
created: 2026-02-02T03:47:06Z
updated: 2026-02-02T03:47:06Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/19
depends_on: [15, 16, 17]
parallel: true
conflicts_with: [17]
---

# Task: MCP Tools - Rule Queries

## Description

Implement MCP tools for querying rulebook content: searching rules, getting specific items (class, race, spell, monster), and validating characters. These tools enable AI agents to access game rules during play.

## Acceptance Criteria

- [ ] `search_rules` tool: Search across all loaded content
- [ ] `get_class` tool: Get full class definition with level progression
- [ ] `get_race` tool: Get full race definition with traits
- [ ] `get_spell` tool: Get spell details
- [ ] `get_monster` tool: Get monster stat block
- [ ] `validate_character` tool: Validate character against rules
- [ ] All tools support TOON output format
- [ ] Proper pagination for large results
- [ ] Source attribution in all responses

## Technical Details

### Tool: search_rules

```python
@mcp.tool
def search_rules(
    query: Annotated[str, Field(description="Search term (name, partial match)")],
    category: Annotated[
        Literal["all", "class", "race", "spell", "monster", "feat", "item"] | None,
        Field(description="Filter by category. Default: all")
    ] = "all",
    limit: Annotated[int, Field(description="Max results", ge=1, le=50)] = 20,
    format: Annotated[Literal["json", "toon"], Field(description="Output format")] = "json",
) -> str:
    """
    Search for rules content across all loaded rulebooks.

    Examples:
    - search_rules("fireball") → Find spells matching "fireball"
    - search_rules("dragon", category="monster") → Find dragon monsters
    """
    if not storage.rulebook_manager:
        return "❌ No rulebooks loaded. Use `load_rulebook` first."

    results = storage.rulebook_manager.search(
        query=query,
        categories=[category] if category != "all" else None,
        limit=limit
    )

    if format == "toon":
        return encode_to_toon([r.to_dict() for r in results])

    # Markdown output with source attribution
    lines = [f"# Search Results: '{query}'\n"]
    for r in results:
        lines.append(f"- **{r.name}** ({r.category}) — _{r.source}_")

    return "\n".join(lines)
```

### Tool: get_class

```python
@mcp.tool
def get_class(
    name: Annotated[str, Field(description="Class name (e.g., 'wizard', 'fighter')")],
    level: Annotated[int | None, Field(description="Show features up to this level", ge=1, le=20)] = None,
    format: Annotated[Literal["json", "toon"], Field(description="Output format")] = "json",
) -> str:
    """
    Get full class definition from loaded rulebooks.

    Examples:
    - get_class("wizard") → Full wizard class info
    - get_class("fighter", level=5) → Fighter features up to level 5
    """
    if not storage.rulebook_manager:
        return "❌ No rulebooks loaded."

    class_def = storage.rulebook_manager.get_class(name.lower())

    if not class_def:
        return f"❌ Class '{name}' not found in loaded rulebooks."

    if format == "toon":
        return encode_to_toon(class_def.model_dump())

    # Detailed markdown output
    return format_class_markdown(class_def, max_level=level)
```

### Tool: get_spell

```python
@mcp.tool
def get_spell(
    name: Annotated[str, Field(description="Spell name (e.g., 'fireball', 'cure wounds')")],
    format: Annotated[Literal["json", "toon"], Field(description="Output format")] = "json",
) -> str:
    """Get spell details from loaded rulebooks."""
    if not storage.rulebook_manager:
        return "❌ No rulebooks loaded."

    spell = storage.rulebook_manager.get_spell(name.lower().replace(" ", "-"))

    if not spell:
        return f"❌ Spell '{name}' not found."

    if format == "toon":
        return encode_to_toon(spell.model_dump())

    return format_spell_markdown(spell)
```

### Tool: get_monster

```python
@mcp.tool
def get_monster(
    name: Annotated[str, Field(description="Monster name (e.g., 'goblin', 'adult-red-dragon')")],
    format: Annotated[Literal["json", "toon"], Field(description="Output format")] = "json",
) -> str:
    """Get monster stat block from loaded rulebooks."""
    if not storage.rulebook_manager:
        return "❌ No rulebooks loaded."

    monster = storage.rulebook_manager.get_monster(name.lower().replace(" ", "-"))

    if not monster:
        return f"❌ Monster '{name}' not found."

    if format == "toon":
        return encode_to_toon(monster.model_dump())

    return format_monster_stat_block(monster)
```

### Tool: validate_character

```python
@mcp.tool
def validate_character(
    name_or_id: Annotated[str, Field(description="Character name or ID to validate")],
    format: Annotated[Literal["json", "toon"], Field(description="Output format")] = "json",
) -> str:
    """
    Validate a character against loaded rulebooks.

    Returns validation report with errors, warnings, and suggestions.
    """
    character = storage.get_character(name_or_id)
    if not character:
        return f"❌ Character '{name_or_id}' not found."

    if not storage.rulebook_manager:
        return "⚠️ No rulebooks loaded. Cannot validate without rules."

    validator = CharacterValidator(storage.rulebook_manager)
    report = validator.validate(character)

    if format == "toon":
        return encode_to_toon(report.to_dict())

    return format_validation_report(report)
```

### Formatter Functions

```python
def format_spell_markdown(spell: SpellDefinition) -> str:
    return f"""# {spell.name}
*{spell.level_text} {spell.school}*

**Casting Time:** {spell.casting_time}
**Range:** {spell.range}
**Components:** {spell.components_text}
**Duration:** {spell.duration}

{spell.description}

*Source: {spell.source}*
"""

def format_monster_stat_block(monster: MonsterDefinition) -> str:
    # Standard 5e stat block format
    ...
```

## Dependencies

- [ ] Task 14: RulebookManager (query interface)
- [ ] Task 15: Storage Integration (manager access)
- [ ] Task 16: Character Validator (validate_character tool)

## Effort Estimate

- Size: M
- Parallel: true (can run with Task 17)

## Definition of Done

- [ ] Six query tools implemented
- [ ] All tools support TOON format
- [ ] Proper error handling for missing content
- [ ] Source attribution in all responses
- [ ] Markdown formatting matches D&D style
- [ ] Integration tests for each tool
- [ ] End-to-end test: load SRD → query spell → validate character
