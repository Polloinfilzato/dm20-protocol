---
name: "Core mapper: identity, abilities, combat, proficiencies"
status: open
created: 2026-02-17T17:01:12Z
updated: 2026-02-17T17:12:58Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/161
depends_on: [159]
parallel: true
conflicts_with: []
---

# Task: Core mapper — identity, abilities, combat stats, proficiencies

## Description

Implement the core mapping functions that translate D&D Beyond's raw JSON into dm20's `Character` model fields. This covers the essential character data: identity (name, race, class, background), ability scores (with modifier aggregation from multiple sources), combat stats (HP, AC, hit dice, speed), and proficiencies (skills, saves, tools, languages).

This is the most complex task in the epic due to DDB's scattered modifier system.

## Acceptance Criteria

- [ ] `map_identity()` correctly maps name, race (with subrace), class (with subclass and level), background, alignment
- [ ] `map_abilities()` computes final ability scores by aggregating: base stats + racial bonuses + ASI + bonus stats + override stats
- [ ] `map_combat()` calculates HP max, HP current, AC, hit dice type/remaining, speed, proficiency bonus
- [ ] `map_proficiencies()` extracts skill proficiencies, saving throw proficiencies, tool proficiencies, and languages from DDB modifiers
- [ ] `map_ddb_to_character()` orchestrates all mappers and returns `ImportResult` with warnings
- [ ] Graceful degradation: if a section fails to map, the character is still created with warnings

## Technical Details

### File: `src/dm20_protocol/importers/dndbeyond/mapper.py`

**Identity mapping:**
```python
def map_identity(ddb: dict) -> tuple[dict, list[str]]:
```
- `ddb["name"]` → `Character.name`
- `ddb["race"]["fullName"]` or `ddb["race"]["baseName"]` → `Race.name`
- `ddb["race"]["subRaceShortName"]` → `Race.subrace` (if present)
- `ddb["classes"][0]["definition"]["name"]` → `CharacterClass.name`
- `ddb["classes"][0]["level"]` → `CharacterClass.level`
- `ddb["classes"][0]["subclassDefinition"]["name"]` → `CharacterClass.subclass` (if present)
- `ddb["background"]["definition"]["name"]` → `Character.background`
- `ddb["alignmentId"]` → lookup via `ALIGNMENT_MAP` → `Character.alignment`
- For multiclass: use highest-level class as primary

**Ability score mapping (complex):**
```python
def map_abilities(ddb: dict) -> tuple[dict[str, AbilityScore], list[str]]:
```
DDB stores ability scores across multiple locations:
1. **Base scores**: `ddb["stats"]` — array of `{"id": 1, "value": 15}` (id 1=STR...6=CHA)
2. **Racial bonuses**: `ddb["modifiers"]["race"]` — filter where `type == "bonus"` and `entityTypeId` matches stat
3. **Class bonuses (ASI)**: `ddb["modifiers"]["class"]` — filter for ability score increases
4. **Bonus stats**: `ddb["bonusStats"]` — array of `{"id": 1, "value": 2}` manual additions
5. **Override stats**: `ddb["overrideStats"]` — array of `{"id": 1, "value": 19}` full overrides (e.g., headband of intellect)
6. **Feat bonuses**: `ddb["modifiers"]["feat"]` — ability score bonuses from feats

Algorithm:
```
for each ability (1-6):
    if overrideStats[id] has non-null value:
        final = overrideStats[id].value
    else:
        final = stats[id].value + sum(all matching bonuses from modifiers) + bonusStats[id].value
    create AbilityScore(score=final)
```

**Combat stats mapping:**
```python
def map_combat(ddb: dict, abilities: dict, level: int) -> tuple[dict, list[str]]:
```
- HP max: `ddb["baseHitPoints"]` + `ddb.get("bonusHitPoints", 0)` + (CON_mod × level)
  - If `ddb["overrideHitPoints"]` is set, use that instead
- HP current: HP max - `ddb.get("removedHitPoints", 0)` + `ddb.get("temporaryHitPoints", 0)`
- AC: Use `ddb["armorClass"]` if available, else calculate from equipment
- Hit dice: derive from class (Fighter=d10, Wizard=d6, etc.)
- Speed: `ddb["race"]["weightSpeeds"]["normal"]["walk"]` or default 30
- Proficiency bonus: auto-calculated by Character model validator

**Proficiency mapping:**
```python
def map_proficiencies(ddb: dict) -> tuple[dict, list[str]]:
```
- Scan all modifier sections (`race`, `class`, `background`, `feat`, `item`)
- Filter where `type == "proficiency"`
- Categorize by `subType`:
  - Skills: "skill" subtype → `skill_proficiencies` list
  - Saves: "saving-throws" subtype → `saving_throw_proficiencies` list
  - Tools: "tool" subtype → `tool_proficiencies` list
- Languages: filter where `type == "language"` → `languages` list

**Orchestrator:**
```python
def map_ddb_to_character(ddb: dict, player_name: str | None = None) -> ImportResult:
```
- Call each mapper, collect warnings
- Construct `Character` model from combined results
- Return `ImportResult` with character, mapped_fields, unmapped_fields, warnings

## Dependencies

- [ ] #159 — Schema constants (STAT_ID_MAP, ALIGNMENT_MAP, etc.)
- [ ] dm20 `Character`, `CharacterClass`, `Race`, `AbilityScore` models

## Effort Estimate

- Size: L
- Hours: 6
- Parallel: true (can run alongside #160 after #159 is done)

## Definition of Done

- [ ] All four mapping functions implemented and working
- [ ] Ability score aggregation handles all modifier sources correctly
- [ ] HP calculation covers base, bonus, override, and removed HP
- [ ] Proficiency extraction covers all modifier sections
- [ ] Orchestrator produces a valid `Character` model
- [ ] Graceful degradation: partial mapping doesn't crash the import
