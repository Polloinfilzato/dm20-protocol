---
name: "Extended mapper: inventory, spells, features, equipment"
status: open
created: 2026-02-17T17:01:12Z
updated: 2026-02-17T17:12:58Z
github: https://github.com/Polloinfilzato/dm20-protocol/issues/162
depends_on: [159, 161]
parallel: true
conflicts_with: [161]
---

# Task: Extended mapper — inventory, spells, features, equipment

## Description

Extend the DDB mapper with functions for inventory items, spellcasting (spells known + spell slots), class/race features, and equipment slot assignment. Also handle secondary data: multiclass support, currency, and character notes/bio from DDB traits.

## Acceptance Criteria

- [ ] `map_inventory()` converts DDB `inventory[]` to dm20 `Item` objects with correct type classification
- [ ] `map_equipment()` detects equipped items and assigns to dm20 equipment slots (weapon_main, weapon_off, armor, shield)
- [ ] `map_spells()` converts DDB spell data to dm20 `Spell` objects with level, school, and prepared status
- [ ] `map_spell_slots()` extracts spell slot configuration from DDB class data
- [ ] `map_features()` extracts class features, racial traits, and feats as dm20 `Feature` objects
- [ ] `map_notes()` maps DDB `traits` (personality, ideals, bonds, flaws) and `notes` to `Character.bio` and `Character.notes`
- [ ] `map_currency()` converts DDB `currencies` to a formatted note or inventory items
- [ ] Multiclass: if multiple classes, highest-level becomes primary; others noted in features/notes

## Technical Details

### File: `src/dm20_protocol/importers/dndbeyond/mapper.py` (extend existing)

**Inventory mapping:**
```python
def map_inventory(ddb: dict) -> tuple[list[Item], list[str]]:
```
- Iterate `ddb["inventory"]`
- For each item:
  - `item["definition"]["name"]` → `Item.name`
  - `item["definition"]["description"]` → `Item.description` (truncate if very long)
  - `item["quantity"]` → `Item.quantity`
  - `item["definition"]["weight"]` → `Item.weight`
  - `item["definition"]["cost"]` → `Item.value` (format as string)
  - `item["definition"]["filterType"]` → lookup via `ITEM_FILTER_TYPE_MAP` → `Item.item_type`
  - Store relevant `properties` (damage dice, AC bonus, etc.) in `Item.properties`

**Equipment slot mapping:**
```python
def map_equipment(ddb: dict, items: list[Item]) -> tuple[dict[str, Item | None], list[str]]:
```
- Scan `ddb["inventory"]` for `equipped == True`
- Match equipped items to dm20 slots:
  - filterType "Weapon" + equipped → `weapon_main` (first) or `weapon_off` (second)
  - filterType "Armor" + equipped → `armor`
  - filterType "Shield" + equipped → `shield`

**Spell mapping:**
```python
def map_spells(ddb: dict) -> tuple[list[Spell], dict[int, int], str | None, list[str]]:
```
- Returns: (spells_known, spell_slots, spellcasting_ability, warnings)
- Iterate `ddb["classSpells"]` (array per class)
- Each entry has `spells[]` with nested `definition`:
  - `definition["name"]` → `Spell.name`
  - `definition["level"]` → `Spell.level`
  - `definition["school"]` → `Spell.school`
  - `definition["castingTime"]` → `Spell.casting_time`
  - `definition["range"]` → `Spell.range`
  - `definition["duration"]` → `Spell.duration`
  - `definition["description"]` → `Spell.description` (truncate)
  - `prepared` flag → `Spell.prepared`
- Spell slots from class data: `ddb["classes"][*]["definition"]["spellRules"]["levelSpellSlots"]`
- Spellcasting ability from class definition

**Feature mapping:**
```python
def map_features(ddb: dict) -> tuple[list[Feature], list[str], list[str]]:
```
- Returns: (features, features_and_traits_legacy, warnings)
- Class features: `ddb["classes"][*]["classFeatures"]` filtered by `requiredLevel <= character level`
  - `name` → `Feature.name`
  - Source: `"{ClassName} {level}"` → `Feature.source`
  - `description` → `Feature.description`
  - `requiredLevel` → `Feature.level_gained`
- Racial traits: `ddb["race"]["racialTraits"]`
  - Source: `"{RaceName}"` → `Feature.source`
- Feats: `ddb["feats"]`
  - Source: `"Feat"` → `Feature.source`
- Also populate legacy `features_and_traits` list with feature names

**Notes/Bio mapping:**
```python
def map_notes(ddb: dict) -> tuple[str | None, str, list[str]]:
```
- Returns: (bio, notes, warnings)
- `ddb["traits"]` contains: `personalityTraits`, `ideals`, `bonds`, `flaws`
- Combine into `bio` field as formatted text
- `ddb["notes"]` sections → `notes` field

**Currency mapping:**
```python
def map_currency(ddb: dict) -> str:
```
- `ddb["currencies"]` has: `pp`, `gp`, `ep`, `sp`, `cp`
- Format as string appended to notes: "Currency: 45 gp, 12 sp, 8 cp"

### Update orchestrator

Update `map_ddb_to_character()` to call the new mapping functions and integrate results into the Character model.

## Dependencies

- [ ] #159 — Schema constants (ITEM_FILTER_TYPE_MAP, SPELL_SCHOOL_MAP)
- [ ] #161 — Core mapper (orchestrator function to extend)
- [ ] dm20 `Item`, `Spell`, `Feature` models

## Effort Estimate

- Size: M
- Hours: 4
- Parallel: true (can run alongside #163 after #161 is done; conflicts_with #161 since both modify mapper.py)

## Definition of Done

- [ ] All extended mapping functions implemented
- [ ] Inventory items correctly classified by type
- [ ] Equipment slots properly assigned for equipped items
- [ ] Spells include level, school, prepared status
- [ ] Features include source attribution and level gained
- [ ] Character bio/notes populated from DDB traits
- [ ] Currency formatted and included in notes
- [ ] Multiclass characters handled (primary class + notes)
