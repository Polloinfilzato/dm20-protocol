"""
Content tagging system for Claudmaster AI DM.

This module provides tagging infrastructure for distinguishing canonical
(from module) vs improvised (AI-generated) content. It tracks content origin,
segments hybrid narratives, and stores tagged content for session notes.

The system enables transparency for players and helps maintain awareness of
how much content comes from the published module vs AI improvisation.
"""

import json
from datetime import datetime, timezone
from enum import Enum
from pathlib import Path
from typing import Optional
from uuid import uuid4

from pydantic import BaseModel, Field

from .improvisation import ImprovisationLevel


class ContentOrigin(str, Enum):
    """
    Classification of content based on its source.

    CANONICAL: Content taken directly from the published module
    IMPROVISED: Content generated by AI agents
    HYBRID: Mix of canonical and improvised content in the same narrative
    """
    CANONICAL = "canonical"
    IMPROVISED = "improvised"
    HYBRID = "hybrid"


class ContentTag(BaseModel):
    """
    Metadata tag for a piece of narrative content.

    Attributes:
        origin: Whether content is canonical, improvised, or hybrid
        confidence: Confidence in the classification (0.0-1.0)
        module_source: Reference to module section if canonical (e.g., "Area 2-B")
        improvisation_level: Level of improvisation if applicable
        timestamp: When this content was tagged
        agent_id: Which agent generated this content
    """
    origin: ContentOrigin = Field(description="Content origin classification")
    confidence: float = Field(ge=0.0, le=1.0, description="Classification confidence")
    module_source: Optional[str] = Field(default=None, description="Module section reference")
    improvisation_level: Optional[ImprovisationLevel] = Field(default=None, description="Improvisation level")
    timestamp: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="When content was tagged"
    )
    agent_id: str = Field(description="Agent that generated the content")


class TaggedSegment(BaseModel):
    """
    A segment of content with its origin classification.

    Used to break down hybrid content into canonical and improvised parts.

    Attributes:
        text: The actual text of this segment
        start_index: Starting character position in the full content
        end_index: Ending character position (exclusive)
        origin: Whether this segment is canonical or improvised
        source_reference: Module section reference if canonical
    """
    text: str = Field(description="Segment text")
    start_index: int = Field(ge=0, description="Start position in content")
    end_index: int = Field(gt=0, description="End position in content")
    origin: ContentOrigin = Field(description="Segment origin")
    source_reference: Optional[str] = Field(default=None, description="Module reference if canonical")


class TaggedNarrative(BaseModel):
    """
    A complete narrative output with origin tagging.

    Represents a single unit of narrative content (e.g., room description,
    NPC dialogue, event narration) with classification of its origin.

    Attributes:
        content: The full narrative text
        tag: Metadata tag for this narrative
        segments: For hybrid content, breakdown into canonical/improvised parts
        narrative_id: Unique identifier (auto-generated UUID)
    """
    content: str = Field(description="Full narrative text")
    tag: ContentTag = Field(description="Content metadata tag")
    segments: list[TaggedSegment] = Field(default_factory=list, description="Segments for hybrid content")
    narrative_id: str = Field(default_factory=lambda: f"narr_{uuid4().hex[:8]}", description="Unique ID")


class TaggedFact(BaseModel):
    """
    A narrative fact with origin tagging.

    Tracks facts established during gameplay and whether they come from
    the module or were improvised by AI agents.

    Attributes:
        fact_id: Unique identifier for this fact
        content: The fact content
        origin_tag: Metadata tag indicating origin
        established_in_session: Session when fact was first established
        last_referenced_session: Most recent session that referenced this fact
        times_referenced: How many times this fact has been referenced
    """
    fact_id: str = Field(default_factory=lambda: f"fact_{uuid4().hex[:8]}", description="Unique ID")
    content: str = Field(description="Fact content")
    origin_tag: ContentTag = Field(description="Origin metadata")
    established_in_session: int = Field(ge=1, description="Session when established")
    last_referenced_session: int = Field(ge=1, description="Last referenced session")
    times_referenced: int = Field(default=1, ge=1, description="Reference count")


class ContentTagger:
    """
    Classifies narrative content as canonical, improvised, or hybrid.

    The tagger uses text similarity (Jaccard coefficient) to determine if
    content matches published module text. It segments hybrid content to
    identify which parts are canonical and which are improvised.

    Attributes:
        module_content: Mapping of section IDs to canonical module text
        similarity_threshold: Jaccard similarity threshold for canonical match (default 0.6)
    """

    def __init__(
        self,
        module_content: dict[str, str],
        similarity_threshold: float = 0.6
    ) -> None:
        """
        Initialize the content tagger.

        Args:
            module_content: Dictionary mapping section IDs to module text
            similarity_threshold: Minimum Jaccard similarity for canonical match
        """
        self.module_content = module_content
        self.similarity_threshold = similarity_threshold

    def tag_narrative(
        self,
        content: str,
        agent_id: str,
        improvisation_level: Optional[ImprovisationLevel] = None
    ) -> TaggedNarrative:
        """
        Tag narrative content with origin classification.

        Analyzes content to determine if it's canonical (from module),
        improvised (AI-generated), or hybrid (mix of both).

        Args:
            content: The narrative text to tag
            agent_id: ID of the agent that generated this content
            improvisation_level: Optional improvisation level setting

        Returns:
            Tagged narrative with origin classification and segments if hybrid
        """
        origin, confidence, module_source = self._classify_origin(content)

        # Create the content tag
        tag = ContentTag(
            origin=origin,
            confidence=confidence,
            module_source=module_source,
            improvisation_level=improvisation_level,
            agent_id=agent_id
        )

        # For hybrid content, segment it
        segments = []
        if origin == ContentOrigin.HYBRID:
            segments = self._segment_hybrid(content)

        return TaggedNarrative(
            content=content,
            tag=tag,
            segments=segments
        )

    def _classify_origin(self, content: str) -> tuple[ContentOrigin, float, Optional[str]]:
        """
        Classify content origin using text similarity.

        Compares content against all module sections using Jaccard similarity.
        High match = canonical, low match = improvised, partial match = hybrid.

        Args:
            content: Text to classify

        Returns:
            Tuple of (origin, confidence, module_source)
        """
        if not self.module_content:
            # No module content loaded, everything is improvised
            return (ContentOrigin.IMPROVISED, 1.0, None)

        # Find best matching module section
        best_match_section = None
        best_similarity = 0.0

        for section_id, module_text in self.module_content.items():
            similarity = self._jaccard_similarity(content, module_text)
            if similarity > best_similarity:
                best_similarity = similarity
                best_match_section = section_id

        # Classify based on similarity threshold
        if best_similarity >= self.similarity_threshold:
            # High match = canonical content
            return (ContentOrigin.CANONICAL, best_similarity, best_match_section)
        elif best_similarity >= self.similarity_threshold * 0.5:
            # Partial match = hybrid content
            return (ContentOrigin.HYBRID, best_similarity, best_match_section)
        else:
            # Low match = improvised content
            return (ContentOrigin.IMPROVISED, 1.0 - best_similarity, None)

    def _jaccard_similarity(self, text1: str, text2: str) -> float:
        """
        Calculate Jaccard similarity between two texts.

        Uses word-level Jaccard coefficient: |A ∩ B| / |A ∪ B|

        Args:
            text1: First text
            text2: Second text

        Returns:
            Similarity score between 0.0 and 1.0
        """
        # Tokenize into words (lowercase, alphanumeric only)
        words1 = set(word.lower() for word in text1.split() if word.isalnum())
        words2 = set(word.lower() for word in text2.split() if word.isalnum())

        if not words1 or not words2:
            return 0.0

        intersection = len(words1 & words2)
        union = len(words1 | words2)

        return intersection / union if union > 0 else 0.0

    def _segment_hybrid(self, content: str) -> list[TaggedSegment]:
        """
        Segment hybrid content into canonical and improvised parts.

        Uses sentence-level matching to identify which sentences come from
        the module and which are improvised additions.

        Args:
            content: Hybrid narrative text

        Returns:
            List of tagged segments
        """
        segments = []
        sentences = self._split_sentences(content)

        position = 0
        for sentence in sentences:
            # Find the sentence in the original content (preserving whitespace)
            start_idx = content.find(sentence, position)
            if start_idx == -1:
                # Shouldn't happen, but handle gracefully
                start_idx = position

            end_idx = start_idx + len(sentence)

            # Classify this sentence
            origin, _, module_ref = self._classify_origin(sentence)

            # Hybrid at sentence level becomes either canonical or improvised
            if origin == ContentOrigin.HYBRID:
                # Treat as improvised for sentence-level segmentation
                origin = ContentOrigin.IMPROVISED

            segments.append(TaggedSegment(
                text=sentence,
                start_index=start_idx,
                end_index=end_idx,
                origin=origin,
                source_reference=module_ref if origin == ContentOrigin.CANONICAL else None
            ))

            position = end_idx

        return segments

    def _split_sentences(self, text: str) -> list[str]:
        """
        Split text into sentences (simple implementation).

        Args:
            text: Text to split

        Returns:
            List of sentences
        """
        # Simple sentence splitting on common terminators
        # This is basic but sufficient for the tagging use case
        sentences = []
        current = []

        for char in text:
            current.append(char)
            if char in '.!?' and len(current) > 1:
                sentences.append(''.join(current))
                current = []

        # Add any remaining text
        if current:
            sentences.append(''.join(current))

        return [s.strip() for s in sentences if s.strip()]


class TaggedContentStore:
    """
    Storage for tagged narrative content and facts.

    Maintains a database of tagged narratives and facts, with support for
    querying, filtering, and managing improvisation approval/rejection.

    Attributes:
        narratives: Dictionary mapping narrative IDs to TaggedNarrative objects
        facts: Dictionary mapping fact IDs to TaggedFact objects
        approval_status: Dictionary tracking improvisation approval/rejection
    """

    def __init__(self) -> None:
        """Initialize the content store."""
        self.narratives: dict[str, TaggedNarrative] = {}
        self.facts: dict[str, TaggedFact] = {}
        self.approval_status: dict[str, tuple[bool, Optional[str]]] = {}
        # Maps narrative_id -> (approved: bool, reason: Optional[str])

    def store_narrative(self, narrative: TaggedNarrative) -> str:
        """
        Store a tagged narrative.

        Args:
            narrative: The narrative to store

        Returns:
            The narrative ID
        """
        self.narratives[narrative.narrative_id] = narrative
        return narrative.narrative_id

    def store_fact(self, tagged_fact: TaggedFact) -> str:
        """
        Store a tagged fact.

        Args:
            tagged_fact: The fact to store

        Returns:
            The fact ID
        """
        self.facts[tagged_fact.fact_id] = tagged_fact
        return tagged_fact.fact_id

    def get_narrative(self, narrative_id: str) -> Optional[TaggedNarrative]:
        """
        Retrieve a narrative by ID.

        Args:
            narrative_id: The narrative ID

        Returns:
            The narrative if found, None otherwise
        """
        return self.narratives.get(narrative_id)

    def get_improvised_content(
        self,
        session_range: Optional[tuple[int, int]] = None,
        agent_filter: Optional[str] = None,
        min_confidence: float = 0.5
    ) -> list[TaggedNarrative]:
        """
        Get all improvised content with optional filters.

        Args:
            session_range: Optional (start_session, end_session) tuple
            agent_filter: Optional agent ID to filter by
            min_confidence: Minimum confidence threshold

        Returns:
            List of improvised narratives matching filters
        """
        results = [
            n for n in self.narratives.values()
            if n.tag.origin == ContentOrigin.IMPROVISED
            and n.tag.confidence >= min_confidence
        ]

        # Apply agent filter
        if agent_filter:
            results = [n for n in results if n.tag.agent_id == agent_filter]

        # Session filtering would require session metadata in narratives
        # For now, we return all matching improvised content

        return results

    def get_canonical_content(
        self,
        module_section: Optional[str] = None
    ) -> list[TaggedNarrative]:
        """
        Get all canonical content, optionally filtered by module section.

        Args:
            module_section: Optional module section ID to filter by

        Returns:
            List of canonical narratives
        """
        results = [
            n for n in self.narratives.values()
            if n.tag.origin == ContentOrigin.CANONICAL
        ]

        if module_section:
            results = [
                n for n in results
                if n.tag.module_source == module_section
            ]

        return results

    def get_hybrid_breakdown(self, narrative_id: str) -> list[TaggedSegment]:
        """
        Get the segment breakdown for hybrid content.

        Args:
            narrative_id: The narrative ID

        Returns:
            List of segments (empty if narrative not found or not hybrid)
        """
        narrative = self.get_narrative(narrative_id)
        if not narrative or narrative.tag.origin != ContentOrigin.HYBRID:
            return []

        return narrative.segments

    def approve_improvisation(self, narrative_id: str) -> bool:
        """
        Mark improvised content as approved (accepted as canon).

        Args:
            narrative_id: The narrative ID to approve

        Returns:
            True if approved successfully, False if narrative not found
        """
        narrative = self.get_narrative(narrative_id)
        if not narrative:
            return False

        self.approval_status[narrative_id] = (True, None)
        return True

    def reject_improvisation(self, narrative_id: str, reason: str) -> bool:
        """
        Mark improvised content as rejected.

        Args:
            narrative_id: The narrative ID to reject
            reason: Reason for rejection

        Returns:
            True if rejected successfully, False if narrative not found
        """
        narrative = self.get_narrative(narrative_id)
        if not narrative:
            return False

        self.approval_status[narrative_id] = (False, reason)
        return True

    def get_session_summary(self, session_number: int) -> dict:
        """
        Get summary statistics for a session.

        Note: This requires narratives to have session metadata.
        Current implementation returns overall stats.

        Args:
            session_number: Session to summarize

        Returns:
            Dictionary with counts of canonical/improvised/hybrid content
        """
        # Count narratives by origin
        canonical_count = sum(
            1 for n in self.narratives.values()
            if n.tag.origin == ContentOrigin.CANONICAL
        )
        improvised_count = sum(
            1 for n in self.narratives.values()
            if n.tag.origin == ContentOrigin.IMPROVISED
        )
        hybrid_count = sum(
            1 for n in self.narratives.values()
            if n.tag.origin == ContentOrigin.HYBRID
        )

        # Count approved/rejected improvisations
        approved = sum(
            1 for nid, (status, _) in self.approval_status.items()
            if status and nid in self.narratives
        )
        rejected = sum(
            1 for nid, (status, _) in self.approval_status.items()
            if not status and nid in self.narratives
        )

        return {
            "session_number": session_number,
            "total_narratives": len(self.narratives),
            "canonical_count": canonical_count,
            "improvised_count": improvised_count,
            "hybrid_count": hybrid_count,
            "approved_improvisations": approved,
            "rejected_improvisations": rejected,
        }

    def save(self, filepath: Path) -> None:
        """
        Save the store to JSON.

        Args:
            filepath: Path to save the store
        """
        data = {
            "narratives": {
                nid: n.model_dump(mode="json")
                for nid, n in self.narratives.items()
            },
            "facts": {
                fid: f.model_dump(mode="json")
                for fid, f in self.facts.items()
            },
            "approval_status": {
                nid: {"approved": status, "reason": reason}
                for nid, (status, reason) in self.approval_status.items()
            }
        }

        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

    def load(self, filepath: Path) -> None:
        """
        Load the store from JSON.

        Args:
            filepath: Path to load from
        """
        if not filepath.exists():
            return

        with open(filepath, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Load narratives
        self.narratives = {
            nid: TaggedNarrative(**ndata)
            for nid, ndata in data.get("narratives", {}).items()
        }

        # Load facts
        self.facts = {
            fid: TaggedFact(**fdata)
            for fid, fdata in data.get("facts", {}).items()
        }

        # Load approval status
        self.approval_status = {
            nid: (status_data["approved"], status_data.get("reason"))
            for nid, status_data in data.get("approval_status", {}).items()
        }


class SessionNotesFormatter:
    """
    Formats session notes with content origin markers.

    Generates markdown-formatted session notes that clearly indicate
    which content is canonical, improvised, or hybrid.
    """

    def format_session_notes(
        self,
        store: TaggedContentStore,
        session_number: int
    ) -> str:
        """
        Format session notes as markdown with origin markers.

        Args:
            store: The content store
            session_number: Session number to format

        Returns:
            Markdown-formatted session notes
        """
        lines = [
            f"# Session {session_number} Notes",
            "",
            "## Summary",
            ""
        ]

        # Get session summary
        summary = store.get_session_summary(session_number)
        lines.extend([
            f"- **Total Narratives**: {summary['total_narratives']}",
            f"- **Canonical**: {summary['canonical_count']}",
            f"- **Improvised**: {summary['improvised_count']}",
            f"- **Hybrid**: {summary['hybrid_count']}",
            "",
            "## Content",
            ""
        ])

        # Format each narrative with origin markers
        for narrative in store.narratives.values():
            origin = narrative.tag.origin.value.upper()
            marker = f"[{origin}]"

            lines.append(f"### {marker} {narrative.narrative_id}")
            lines.append("")

            if narrative.tag.module_source:
                lines.append(f"*Source: {narrative.tag.module_source}*")
                lines.append("")

            # For hybrid content, show segment breakdown
            if narrative.tag.origin == ContentOrigin.HYBRID and narrative.segments:
                lines.append("**Segmented Content:**")
                lines.append("")
                for seg in narrative.segments:
                    seg_marker = f"[{seg.origin.value.upper()}]"
                    lines.append(f"- {seg_marker} {seg.text}")
                lines.append("")
            else:
                lines.append(narrative.content)
                lines.append("")

            # Show approval status if applicable
            if narrative.narrative_id in store.approval_status:
                approved, reason = store.approval_status[narrative.narrative_id]
                status = "APPROVED" if approved else "REJECTED"
                lines.append(f"*Status: {status}*")
                if reason:
                    lines.append(f"*Reason: {reason}*")
                lines.append("")

        return "\n".join(lines)


__all__ = [
    "ContentOrigin",
    "ContentTag",
    "TaggedSegment",
    "TaggedNarrative",
    "TaggedFact",
    "ContentTagger",
    "TaggedContentStore",
    "SessionNotesFormatter",
]
